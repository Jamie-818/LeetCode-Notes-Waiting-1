## 10亿个数中如何高效地找到最大的一个数以及最大的第K个数
### 1. 10亿个数中如何高效地找到最大的一个数
将1亿个数据分成100份，每份100万个数据，找到每份数据中最大的那个数据，最后在剩下的100个数据里面找出最大的数据。
从100万个数据遍历选择最大的数，此方法需要每次的内存空间为10^6*4=4MB，一共需要100次这样的比较。

### 2. 10亿个数中如何高效地找到第K个数
对于top K类问题，通常比较好的方案是分治+Trie树/hash+小顶堆

先拿10000个数建小顶堆，然后一次添加剩余元素，如果大于堆顶的数（K中最小的），将这个数替换堆顶，并调整结构使之仍然是一个最小堆，这样，遍历完后，堆中的K个数就是所需的最大的K个。建堆时间复杂度是O（KlogK），算法的时间复杂度为O（nKlogK）（n为10亿）。

- 优化的方法：可以把所有10亿个数据分组存放，比如分别放在K个文件中。这样处理就可以分别在每个文件的10^6个数据中找出最大的K个数，合并到一起在再找出最终的结果。


### 3. top K常用的方法
- 快排：排序后的集合中进行查找
    - 时间复杂度： 时间复杂度为（nlogn）
    - 缺点：需要比较大的内存，且效率低
- 局部淘汰：用容器保存K个数，剩下的数和容器内最小的数比较和替换，一直保留最大的K个数在容器中
    - 时间复杂度： 时间复杂度为O（n+K^2）
- 分治法：将1亿个数据分成100份，每份100万个数据，找到每份数据中最大的K个，最后在剩下的100*K个数据里面找出最大的K个，100万个数据里面查找最大的K个数据可以使用Partition的方法
    - 时间复杂度： 时间复杂度为O（n+100*K）
- Hash法： 如果这1亿个书里面有很多重复的数，先通过Hash法，把这1亿个数字去重复，这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间，然后通过分治法或最小堆法查找最大的K个数。
- 小顶堆： 首先读入前10000个数来创建大小为10000的小顶堆，建堆的时间复杂度为O（KlogK），然后遍历后续的数字，并于堆顶（最小）数字进行比较。如果比最小的数小，则继续读取后续数字；如果比堆顶数字大，则替换堆顶元素并重新调整堆为最小堆。
    - 时间复杂度： 时间复杂度为O（nKlogK）

### 4. 实际情况
（1）**单机+单核+足够大内存**
- 顺序遍历（或先用HashMap求出每个词出现的频率）
    - 查找10亿个查询次（每个占8B）中出现频率最高的10个，考虑到每个查询词占8B，则10亿个查询次所需的内存大约是10^9 * 8B=8GB内存。如果有这么大内存，直接在内存中对查询次进行排序，顺序遍历找出10个出现频率最大的即可。
    - 优点： 简单快速

（2）单机+多核+足够大内存
- partition + （1）
    - 直接在内存总使用Hash方法将数据划分成n个partition，每个partition交给一个线程处理，线程的处理逻辑同（1）类似，最后一个线程将结果归并。
    - 瓶颈：数据倾斜。每个线程的处理速度可能不同，快的线程需要等待慢的线程。
    - 解决的方法：将数据划分成c×n个partition（c>1），每个线程处理完当前partition后主动取下一个partition继续处理，知道所有数据处理完毕，最后由一个线程进行归并。

（3）单机+单核+受限内存
- 分治 + （1）
    - 将原文件中的数据切割成M小文件，如果小文件仍大于内存大小，继续采用Hash的方法对数据文件进行分割，直到每个小文件小于内存大小，这样每个文件可放到内存中处理。采用（1）的方法依次处理每个小文件。

（4）多机+受限内存
- 数据分发 + （3）
    - 将数据分发到多台机器上，每台机器采用（3）中的策略解决本地的数据。可采用hash+socket方法进行数据分发。
- MapReduce
    - top K问题很适合采用MapReduce框架解决，用户只需编写一个Map函数和两个Reduce 函数，然后提交到Hadoop
         - 首先根据数据值或者把数据hash(MD5)后的值按照范围划分到不同的机器上，最好可以让数据划分后一次读入内存，这样不同的机器负责处理不同的数值范围，实际上就是Map。
         - 得到结果后，各个机器只需拿出各自出现次数最多的前N个数据，然后汇总，选出所有的数据中出现次数最多的前N个数据，这实际上就是Reduce过程。
         - 对于Map函数，采用Hash算法，将Hash值相同的数据交给同一个Reduce task；对于第一个Reduce函数，采用HashMap统计出每个词出现的频率，对于第二个Reduce 函数，统计所有Reduce task，输出数据中的top K即可。